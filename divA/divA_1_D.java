/*
 * D. Футурама
 * 
 * // Условие
 * Ограничение времени 	1 секунда
 * Ограничение памяти 	64Mb
 * Ввод 	стандартный ввод или input.txt
 * Вывод 	стандартный вывод или output.txt
 * 
 * С помощью изобретенной профессором машины Фарнсворт и Эми меняются телами с целью 
 * осуществить свои мечты: профессор жаждет острых ощущений, а Эми мечтает есть от пуза,
 * не опасаясь за фигуру. Впоследствии выясняется, что обмен разумом между двумя телами
 * возможен не более одного раза, и чтобы вернуться обратно в свои тела нужно произвести 
 * промежуточный обмен. Бендер предлагает свою помощь, однако, заполучив тело Эми, он тут
 * же скрывается, чтобы под чужой личиной украсть корону императора Робо-Венгрии.
 * 
 * Эми, недовольная возможностями профессорского тела в плане обжорства, уговаривает
 * поменяться Лилу. Фрай приходит в ужас. Лила обижена и обвиняет Фрая в том, что его
 * заботит только ее внешность. Фрай в отместку меняется телами с Зойдбергом.
 * 
 * Бендер оказывается пойман при попытке ограбления, однако освобождается, убедив императора
 * в том, что он - робот в теле человека. Узнав, что император втайне мечтает пожить немного
 * жизнью простых людей, Бендер предлагает тому на время поменяться телами. Но так как
 * Профессор уехал рисковать жизнью в теле Бендера, пришлось подсунуть императору вместо
 * своего корпуса автоматизированное помойное ведро.
 * 
 * Фрай в теле Зойдберга и Лила в теле Профессора встречаются в ресторане, чтобы выяснить
 * отношения. В конце концов они понимают, что любят друг друга вовсе не за внешность.
 * При виде сцены их бурного примирения Эми, на этот раз уже в теле Гермеса, надолго теряет
 * аппетит.
 * 
 * Бендер, поменявшись телами с правителем Робо-Венгрии, наслаждается жизнью на его яхте.
 * Однако именно в этот вечер заговорщики совершают покушение на императора. Жизнь Бендеру
 * спасает появление профессора Фарнсворта.
 * 
 * После того, как все герои решают свои личные проблемы, профессору с помощью Бубльгума
 * Тэйта и Сладкого Клайда из команды "Ударники" удается вернуть всех в свои тела.
 * 
 * "Футурама". Десятый эпизод шестого сезона.
 * 
 * В очередной серии Футурамы было проведено несколько обменов разумами между телами героев,
 * но, по крайней мере Бубльгум Тэйт и Сладкий Клайд в обменах не участвовали. Теперь 
 * необходимо вернуть разумы всех героев в свои тела. К сожалению, два тела могут участвовать
 * только в одном обмене,поэтому обратные обмены для этого произвести невозможно. Например,
 * если тело 1 поменялось разумом с телом 2, а потом тело 1 поменялось разумом с телом 3, то
 * в теле 1 находится разум третьего героя, в теле 2 - разум первого героя, а в теле 3 -
 * - второго. Теперь можно произвести обмен разумами только между телами 2 и 3, тогда разум
 * второго героявернется в свое тело, а первому и третьему героям могут помочь только Тэйт
 * с Клайдом.
 * 
 * Помогите героям Футурамы вернуться в свои тела.
 * 
 * // Формат ввода
 * Во входном файле записаны целые числа N (4 ≤ N ≤ 20) и M(1 ≤ M ≤ 100) - количество героев
 * Футурамы и количество произведенных обменов разумами.Герои занумерованы числами от 1 до N,
 * изначально разум каждого из героев находится в своем теле. В последующих M строчках
 * записана последовательность совершенных обменов разумами. Каждый обмен описывается двумя
 * различными числами - номерами тел, которые, в этом обмене меняются разумами. Бубльгум 
 * Тэйт и Сладкий Клайд, как наиболее разумные герои, имеют номера N−1 и N, и гарантируется,
 * что в исходных обменах они не участвовали.
 * 
 * // Формат вывода
 * Выведите план обменов для возвращения разумов героев в свои телав виде пар различных
 * чисел - номеров тел которые участвовали в соответствующем обмене.Причем никакие два тела
 * не должны обмениваться между собой разумами более одного раза,включая исходные обмены. 
 * Если обменов не требуется, то можно ничего не выводить.Если планов обменов несколько, 
 * то выведите любой из них (не обязательно минимальный).
 * 
 * Вернуть разумы героев в свои тела всегда возможно.
 * 
 * // Примеры
 * 4 1
 * 1 2
 * 
 * 1 3 
 * 2 4
 * 1 4
 * 2 3
 * 3 4
 * 
 * 5 1
 * 1 2
 * 
 * 1 4
 * 2 5
 * 1 5
 * 2 4
 * 4 5
 * 
 * // Решение
 * Рассмотрим несколько ситуаций. Пускай произошло несколько преобразований и схема 
 * тел-разумов, выстроенная в цепочку имеет следующий вид: 1(2) -> 2(3) -> ... -> n(1) , 
 * где первое число определяет тело, а второе - разум персонажа.  *  * Добавим нового
 * персонажа. Если этот персонаж взаимодействует с уже имеющимися в цепочке персонажами,
 * то он удлиняет цепочку вне зависимости от положения в цепочке того персонажа, с которым
 * он взаимодействует: 
 * 1(x) -> x(2) -> 2(3) -> ... -> n(1). 
 * Если персонаж взаимодействует с новым персонажем, то они создают новую цепочку. 
 * Персонажи, взаимодействующие внутри одной цепочки укорачивают её или делят цепь на две:
 * 1(2) -> 2(3) -> 3(4) -> 4(1);
 * 1 <-> 3;
 * 1(4) -> 4(1), 2(3) -> 3(2);
 * Персонажи из разных цепочек, взаимодействущие друг с другом, собирают две цепи в одну:
 * 1(2) -> 2(1), 3(4) -> 4(5) -> 5(3);
 * 1 <-> 3;
 * 1(4) -> 4(5) -> 5(3) -> 3(2) -> 2(1);
 * Иными словами, после всех преобразований будет одна или несколько цепей.
 * Есть два персонажа, которые не участвовали в обменах, соответственно, могут единоразово
 * произвести обмен с любым из этих персонажей. Используем одного из них, чтобы пройтись по
 * всей цепочке - зная, что каждый персонаж в цепи владеет разумом следующего, поочередно 
 * взаимодействуя с каждым из них, можно вернуть свой разум каждому, кроме самого первого:
 * 1(2) -> 2(3) -> 3(4) -> 4(1); x(x);
 * x <-> 1;
 * 1(x) -> x(2) -> 2(3) -> 3(4) -> 4(1);
 * x <-> 2;
 * 1(x) -> x(3) -> 3(4) -> 4(1); 2(2);
 * x <-> 3;
 * 1(x) -> x(4) -> 4(1); 3(3);
 * x <-> 4;
 * 1(x) -> x(1); 4(4);
 * Первому вернуть разум не получится, поскольку с ним уже произошёл обмен. Чтобы была 
 * возможность вернуть разум первому персонажу в цепи, второй помощник должен выступить в 
 * роли буфера и забрать разум первого персонажа цепи у последнего персонажа. Вернемся на
 * один обмен назад:
 * 1(x) -> x(4) -> 4(1); y(y);
 * y <-> 4;
 * 1(x) -> x(4) -> 4(y) -> y(1);
 * Теперь первый помощник может безопасно произвести обмен с изначально последним 
 * персонажем в цепи:
 * x <-> 4;
 * 1(x) -> x(y) -> y(1); 4(4);
 * y <-> 1;
 * x(y) -> y(x); 1(1);
 * Поскольку цепей несколько, то производить обмен между x и y имеет смысл в самом конце, 
 * если в нём будет необходимость.
 * Таким образом получаем следующий алгоритм - производить обмен первым помощником с каждым 
 * персонажем в цепи кроме последнего. Второй помощник производит обмен с последним и первым
 * персонажами цепи, первый помощник теперь может произвести обмен с последним персонажем 
 * цепи. Повторить для каждой цепи, в случае необходимости после всех обменов произвести 
 * обмен между помощниками.
 * 
 */

import java.util.*;

public class Test {

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        int[] input = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int numOfHeroes = input[0], numOfSwaps = input[1];

        Map<Integer, Hero> heroes = new HashMap<>();
        for (int i = 0; i < numOfSwaps; i++) {
            input = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
            int firstHeroId = input[0], secondHeroId = input[1];
            heroes.putIfAbsent(firstHeroId, new Hero(firstHeroId));
            heroes.putIfAbsent(secondHeroId, new Hero(secondHeroId));
            Hero.swapMinds(heroes.get(firstHeroId), heroes.get(secondHeroId));
        }

        List<List<Hero>> chains = new ArrayList<>();
        Set<Hero> alreadyChainedHeroes = new HashSet<>();
        for (Hero hero : heroes.values()) {
            if (alreadyChainedHeroes.contains(hero))
                continue;
            if (hero.bodyId == hero.mindId)
                continue;

            Hero firstHeroInChain = hero;
            List<Hero> chain = new ArrayList<>(Arrays.asList(firstHeroInChain));
            alreadyChainedHeroes.add(hero);
            do {
                hero = heroes.get(hero.mindId);
                chain.add(hero);
                alreadyChainedHeroes.add(hero);
            } while (hero.mindId != firstHeroInChain.bodyId);
            chains.add(chain);
        }

        int firstHelperId = numOfHeroes - 1, secondHelperId = numOfHeroes;
        StringBuilder swaps = new StringBuilder();
        for (List<Hero> chain : chains) {
            chain.stream()
                    .limit(chain.size() - 1)
                    .forEach(hero -> swaps.append(hero.bodyId).append(" ").append(firstHelperId).append("\n"));
            Hero firstHero = chain.get(0), lastHero = chain.get(chain.size() - 1);
            swaps.append(lastHero.bodyId).append(" ").append(secondHelperId).append("\n");
            swaps.append(lastHero.bodyId).append(" ").append(firstHelperId).append("\n");
            swaps.append(firstHero.bodyId).append(" ").append(secondHelperId).append("\n");
        }
        if (chains.size() % 2 != 0)
            swaps.append(firstHelperId).append(" ").append(secondHelperId).append("\n");
        System.out.println("\n" + swaps);
    }
}

class Hero {
    int bodyId, mindId;

    Hero(int id) {
        bodyId = id;
        mindId = id;
    }

    static void swapMinds(Hero firstHero, Hero secondHero) {
        int buffer = firstHero.mindId;
        firstHero.mindId = secondHero.mindId;
        secondHero.mindId = buffer;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Hero)) return false;
        Hero hero = (Hero) o;
        return bodyId == hero.bodyId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(bodyId);
    }
}