/*
 * C. Драгоценные камни
 * 
 * // Условие
 * Ограничение времени 	1 секунда
 * Ограничение памяти 	64Mb
 * Ввод 	стандартный ввод или input.txt
 * Вывод 	стандартный вывод или output.txt
 * 
 * В одной далекой восточной стране до сих пор по пустыням ходят караваны верблюдов, 
 * с помощью которых купцы перевозят пряности, драгоценности и дорогие ткани. Разумеется,
 * основная цель купцов состоит в том, чтобы подороже продать имеющийся у них товар.
 * Недавно один из караванов прибыл во дворец одного могущественного шаха.
 * 
 * Купцы хотят продать шаху n драгоценных камней, которые они привезли с собой. Для этого
 * они выкладывают их перед шахом в ряд, после чего шах оценивает эти камни и принимает
 * решение о том, купит он их или нет. Видов драгоценных камней на Востоке известно не очень
 * много всего 26, поэтому мы будем обозначать виды камней с помощью строчных букв латинского
 * алфавита. Шах обычно оценивает камни следующим образом. Он заранее определил несколько
 * упорядоченных пар типов камней: (a1, b1), (a2, b2), ..., (ak, bk). Эти пары он называет
 * красивыми, их множество мы обозначим как P. Теперь представим ряд камней, которые продают
 * купцы, в виде строки S длины n из строчных букв латинского алфавита. Шах считает число 
 * таких пар (i, j), что 1 ≤ i < j ≤ n, а камни Si и Sj образуют красивую пару, то есть 
 * существует такое число 1 ≤ q ≤ k, что Si = aq и Sj = bq.
 * 
 * Если число таких пар оказывается достаточно большим, то шах покупает все камни. Однако
 * в этот раз купцы привезли настолько много камней, что шах не может посчитать это число.
 * Поэтому он вызвал своего визиря и поручил ему этот подсчет. Напишите программу, которая
 * находит ответ на эту задачу.
 * 
 * // Формат ввода
 * Первая строка входного файла содержит целые числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ 676)
 * число камней, которые привезли купцы и число пар, которые шах считает красивыми. 
 * Вторая строка входного файла содержит строку S, описывающую типы камней, которые
 * привезли купцы.
 * 
 * Далее следуют k строк, каждая из которых содержит две строчных буквы латинского алфавита
 * и описывает одну из красивых пар камней.
 * 
 * // Формат вывода
 * В выходной файл выведите ответ на задачу — количество пар, которое должен найти визирь.
 * 
 * // Примеры
 * 7 1
 * abacaba
 * aa
 * 
 * 6
 * 
 * 7 3
 * abacaba
 * ab
 * ac
 * bb
 * 
 * 7
 * 
 * // Решение
 * Нет нужды перебирать всю последовательность в поисках букв, из которых состоит пара,
 * если заранее составить словарь, где ключом будет буква, а значением - список позиций,
 * на которых она встречается в последовательности. Для каждой позиции первой буквы в паре
 * следует определить, сколько раз встречается вторая буква. Зная позицию первой буквы, 
 * можно найти бинарным поиском ближайшую справа позицию второй буквы и индекс этой позиции
 * в соответствующем списке. Зная индекс, можно вычислить количество букв после заданной
 * позиции, вычитая индекс из размера списка. 
 * Можно заметить, что нет нужды использовать бинарный поиск всякий раз для поиска новой
 * ближайшей справа позиции второй буквы - первая буква сдвигается только вправо, позиция 
 * второй буквы сдвигается вслед за ней, пока не начнёт превышать её. Эта позиция будет 
 * ближайшей справа ко всем последующим позициям первой буквы до тех пор, пока очередная
 * позиция первой буквы не станет превышать её. Таким образом список позиций второй буквы
 * будет пройден только один раз без возвратов.
 * 
 */

import java.util.*;
import java.util.stream.*;

public class Test {

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split(" ");
        String s = scanner.nextLine();
        Map<Character, List<Integer>> charOccurrencePositions =
                IntStream.range(0, s.length()).boxed().collect(Collectors.groupingBy(s::charAt, Collectors.toList()));

        List<String> combos = new ArrayList<>();
        for (int i = 0; i < Integer.parseInt(input[1]); i++) {
            combos.add(scanner.nextLine());
        }

        int cnt = 0;
        for (String pattern : combos) {
            char firstCharInCombo = pattern.charAt(0), secondCharInCombo = pattern.charAt(1);
            if (charOccurrencePositions.containsKey(firstCharInCombo) && charOccurrencePositions.containsKey(secondCharInCombo)) {
                List<Integer>
                        firstCharOccurrencePositions = charOccurrencePositions.get(firstCharInCombo),
                        secondCharOccurrencePositions = charOccurrencePositions.get(secondCharInCombo);
                int secondCharStartPos = 0;
                for (Integer firstCharOccPos : firstCharOccurrencePositions) {
                    while (secondCharStartPos != secondCharOccurrencePositions.size()
                            && secondCharOccurrencePositions.get(secondCharStartPos) <= firstCharOccPos)
                        secondCharStartPos++;
                    if (secondCharStartPos == secondCharOccurrencePositions.size())
                        break;
                    cnt += secondCharOccurrencePositions.size() - secondCharStartPos;
                }
            }
        }
        System.out.println(cnt);
    }
}