/*
 * D. Жребий Крижановского
 * 
 * // Условие
 * Ограничение времени 	1 секунда
 * Ограничение памяти 	64Mb
 * Ввод 	стандартный ввод или input.txt
 * Вывод 	стандартный вывод или output.txt
 * 
 * Петя играет с друзьями в игру, которую иногда называют "Жребий Крижановского". Правила 
 * игры следующие: в каждом туре каждый игрок загадывает произвольное натуральное число. 
 * После этого игрок, загадавший минимальное число, которое не повторяется, выигрывает в
 * этом туре, причем его выигрыш равен этому числу. Например, если играют 6 человек и были
 * загаданы числа 3, 2, 1, 1, 4 и 2, то выиграл первый игрок, причем его выигрыш равен 3.
 * Если все загаданные числа повторяются, то тур считается ничейным и никто баллов не получает.
 * 
 * Общий выигрыш игрока за игру равен сумме баллов за все сыгранные туры.
 * 
 * Петя с друзьями при игре просто называют по очереди загаданные ими числа, а потом 
 * определяют, кто выиграл, и подсчитывают баллы. Однако при таком формате игры в принципе
 * можно сжульничать, не загадывая число заранее, а, уже зная числа, названные предыдущими
 * игроками, выбрать себе оптимальное "загаданное" число. Этим и пользуется Петя. Он называет
 * число последним и старается выбрать число так, чтобы максимизировать свой выигрыш.
 * 
 * Идет последний тур игры. Известны очки всех игроков перед этим туром и названные игроками
 * числа. Выясните, какое число следует назвать Пете, чтобы по результатам игры у как можно
 * большего числа игроков количество баллов было меньше, чем у него. Если таких чисел
 * несколько, то Петя хочет назвать минимальное возможное.
 * 
 * // Формат ввода
 * В первой строке вводится число n - количество игроков (2 ≤ n ≤ 100). Вторая строка 
 * содержит n чисел - баллы игроков перед последним туром (неотрицательные целые числа,
 * не большие 100). Баллы перечислены в том порядке, в котором игроки обычно называют 
 * числа (то есть Петины баллы указаны последними). В третьей строке задано (n-1) число -
 * - числа, названные игроками в последнем туре (числа не превышают 100), в том порядке,
 * в котором они их называли.
 * 
 * // Формат вывода
 * Выведите число, которое следует назвать Пете. 
 * 
 * // Примеры
 * 6
 * 0 0 0 0 0 0
 * 2 3 4 5 6
 * 
 * 1
 * 
 * 6
 * 8 3 12 5 0 9
 * 2 1 3 1 4
 * 
 * 2
 * 
 * 8
 * 0 0 0 0 0 0 0 0
 * 1 1 2 2 3 3 4
 * 
 * 1
 * 
 * // Решение
 * Для начала имеет смысл определить, есть ли победитель. Также нас интересует второй игрок,
 * который выиграет в случае, если шулер поставит ту же ставку, что и победитель. Только
 * у этих двух и шулера может измениться итоговый счёт в ходе одной партии. Для того чтобы
 * выявить "победителей", необходимо из списка игроков отфильтровать всех игроков с 
 * дублирующимися ставками, а оставшихся отсортировать по возрастанию ставок. Первые два
 * человека, если таковые будут, и окажутся победителями.
 * Далее проверим, а имеет ли смысл шулеру побеждать - если никакая из его ставок в итоге 
 * не приведёт к улучшению его счёта относительно других, то, возможно, она не является 
 * лучшей == наименьшей и необходимо использовать другой алгоритм. 
 * Для этого отфильтруем всех игроков, счёт которых меньше, чем у шулера - их положение 
 * относительно шулера уже не изменится. Оставшихся отсортируем по убыванию счёта. 
 * Переберём их. Для текущего игрока найдём минимальную ставку, которая обеспечит шулеру 
 * улучшение счёта относительно этого игрока. Начиная со ставки равной разнице между 
 * их счетами + 1 проверяем, не поставил ли такую же ставку кто-то другой из игроков, 
 * т.е. не является ли она заведомо проигрышной, и увеличиваем её на один, если да.
 * Расти она может вплоть до максимального значения (100). После того, как минимальная 
 * ставка найдена, проверим, является ли она выигрышной. Если победителя нет или победитель
 * есть, но его ставка больше той, которую мы нашли, то шулер побеждает и при текущей ставке
 * его счёт превышает счёт наибольшего возможного количества игроков. В противном случае 
 * переходим к следующему игроку. Если игроков больше нет, а ставка так и не нашлась, 
 * значит шулеру не имеет смысла побеждать. 
 * Далее необходимо понять, может ли шулер позволить себе проиграть. 
 * Если потенциальных победителей двое, то шулер может помешать первому выиграть и тогда
 * победит второй. Если независимо от того, кому из них шулер позволил выиграть, счёт 
 * победителя станет превышать его (до победы при этом он должен быть меньше), то для шулера
 * вообще не имеет смысла делать ставку, отличную от 1 - количество игроков, которых он 
 * опережает, всё равно уменьшится на 1. 
 * Аналогично, если в результате победы ни первый ни второй победитель не могут опередить
 * шулера (или уже опережали его до победы), то шулеру следует сделать ставку 1.
 * В остальных случаях, если первый победитель опережает шулера, то мешаем ему и делаем 
 * такую же ставку. Если не опережает - то не мешаем ему побеждать и делаем ставку 1, 
 * либо 2 если первая уже занята победителем.
 * Если победителей нет вообще, то ставка всё равно 1.
 * 	
 * Upd: По неземной логике сотрудников яндекса все игроки при выборе ставки ограничены 
 * числом 100, а шулер нет.
 * Строка 
 * ".filter(bet -> bet <= 100 && (!firstWinner.isPresent() || firstWinner.get().bet > bet))" 
 * изменена на 
 * ".filter(bet -> bet <= 101 && (!firstWinner.isPresent() || firstWinner.get().bet > bet))" 
 * 
 */

import java.util.*;
import java.util.stream.Collectors;

public class Test {

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        scanner.nextLine();
        List<Integer> playersScore = Arrays.stream(scanner.nextLine().split(" ")).map(Integer::parseInt).collect(Collectors.toList());
        List<Integer> playersBets = Arrays.stream(scanner.nextLine().split(" ")).map(Integer::parseInt).collect(Collectors.toList());
        List<Player> players = new ArrayList<>();
        for (int i = 0; i < playersBets.size(); i++)
            players.add(new Player(i, playersScore.get(i), playersBets.get(i)));
        int cheaterId = playersScore.size() - 1;
        Player cheater = new Player(cheaterId, playersScore.get(cheaterId), 0);

        Map<Integer, List<Player>> playersByBet = players.stream()
                .collect(Collectors.groupingBy(Player::getBet, TreeMap::new, Collectors.toList()));
        List<Player> possibleWinners = playersByBet.values().stream()
                .filter(_players -> _players.size() == 1)
                .map(_players -> _players.get(0))
                .limit(2)
                .collect(Collectors.toList());
        Optional<Player> firstWinner = possibleWinners.size() > 0 ? Optional.of(possibleWinners.get(0)) : Optional.empty();
        Optional<Player> secondWinner = possibleWinners.size() > 1 ? Optional.of(possibleWinners.get(1)) : Optional.empty();

        Optional<Integer> bestWinningBet = players.stream()
                .map(Player::getScore)
                .filter(score -> score >= cheater.score)
                .sorted(Comparator.reverseOrder())
                .map(playerScore -> {
                    int bet = playerScore - cheater.score + 1;
                    while (playersByBet.containsKey(bet))
                        bet++;
                    return bet;
                })
                .filter(bet -> bet <= 101 && (!firstWinner.isPresent() || firstWinner.get().bet > bet))
                .findFirst();

        int bet;
        if (bestWinningBet.isPresent())
            bet = bestWinningBet.get();
        else {
            boolean firstWinnerIsGettingAheadOfCheater =
                    firstWinner.isPresent()
                            && firstWinner.get().score < cheater.score
                            && firstWinner.get().score + firstWinner.get().bet >= cheater.score;
            boolean secondWinnerIsGettingAheadOfCheater =
                    secondWinner.isPresent()
                            && secondWinner.get().score < cheater.score
                            && secondWinner.get().score + secondWinner.get().bet >= cheater.score;
            if (firstWinnerIsGettingAheadOfCheater == secondWinnerIsGettingAheadOfCheater)
                bet = 1;
            else
                bet = (firstWinnerIsGettingAheadOfCheater)
                        ? firstWinner.get().bet
                        : (firstWinner.isPresent() && firstWinner.get().bet == 1) ? 2 : 1;
        }
        System.out.println(bet);
    }
}

class Player {

    int id, score, bet;

    Player(int id, int score, int bet) {
        this.id = id;
        this.score = score;
        this.bet = bet;
    }

    int getBet() {
        return bet;
    }

    int getScore() {
        return score;
    }
}