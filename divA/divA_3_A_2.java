/*
 * A. Угадай число - 2
 * 
 * // Условие
 * Ограничение времени 	1 секунда
 * Ограничение памяти 	64Mb
 * Ввод 	стандартный ввод или input.txt
 * Вывод 	стандартный вывод или output.txt
 * 
 * Август загадал натуральное число от 1 до n. Беатриса пытается угадать это число, для 
 * этого она называет некоторые множества натуральных чисел. Август отвечает Беатрисе YES,
 * если среди названных ей чисел есть задуманное или NO в противном случае. После нескольких
 * заданных вопросов Беатриса запуталась в том, какие вопросы она задавала и какие ответы
 * получила и просит вас помочь ей определить, какие числа мог задумать Август.
 * 
 * Август и Беатриса продолжают играть в игру, но Август начал жульничать. На каждый из 
 * вопросов Беатрисы он выбирает такой вариант ответа YES или NO, чтобы множество возможных
 * задуманных чисел оставалось как можно больше. Например, если Август задумал число от 1 до 5,
 * а Беатриса спросила про числа 1 и 2, то Август ответит NO, а если Беатриса спросит 
 * про 1, 2, 3, то Август ответит YES. Если же Бетриса в своем вопросе перечисляет ровно 
 * половину из задуманных чисел, то Август из вредности всегда отвечает NO. Наконец, Август
 * при ответе учитывает все предыдущие вопросы Беатрисы и свои ответы на них, то есть
 * множество возможных задуманных чисел уменьшается.
 * 
 * // Формат ввода
 * Вам дана последовательность вопросов Беатрисы. Приведите ответы Августа на них. Первая 
 * строка входных данных содержит число n — наибольшее число, которое мог загадать Август.
 * Далее идут строки, содержащие вопросы Беатрисы. Каждая строка представляет собой набор
 * чисел, разделенных пробелами. Последняя строка входных данных содержит одно слово HELP.
 * 
 * // Формат вывода
 * Для каждого вопроса Беатрисы выведите ответ Августа на этот вопрос. После этого выведите
 * (через пробел, в порядке возрастания) все числа, которые мог загадать Август после ответа
 * на все вопросы Беатрисы. 
 * 
 * // Примеры
 * 10
 * 1 2 3 4 5
 * 2 4 6 8 10
 * HELP
 * 
 * NO
 * YES
 * 6 8 10
 * 
 * 10
 * 1
 * 2
 * 3
 * 4
 * 5
 * 6
 * 7
 * 8
 * 9
 * HELP
 * 
 * NO
 * NO
 * NO
 * NO
 * NO
 * NO
 * NO
 * NO
 * NO
 * 10
 * 
 * 16
 * 1 2 3 4 5 6 7 8
 * 9 10 11 12
 * 13 14
 * 16
 * HELP
 * 
 * NO
 * NO
 * NO
 * NO
 * 15
 * 
 * // Решение
 * Заведем коллекцию, в которой будут храниться все возможные загаданные числа. Её можно 
 * завести предварительно, до обработки вопросов, добавив туда все числа в заданном
 * диапазоне, или создать после первого вопроса. 
 * Для каждого вопроса отфильтруем из него те значения, которых нет в коллекции, по 
 * количеству оставшихся определим, каким будет ответ игрока (согласно условию - если
 * количество чисел в вопросе с отфильтрованными значениями меньше либо равно половине 
 * от возможных загаданных чисел, то ответ - "нет", иначе - "да". В этом случае в коллекции
 * останется наибольшее возможное количество чисел). Если ответ был отрицательный, то удаляем
 * из коллекции числа, которые были в вопросе, если положительный - то оставляем только их
 * (или просто оставляем вопрос в качестве коллекции загаданных чисел). 
 * Для быстрых операций определения находится ли число в данной коллекции лучше
 * использовать HashSet.
 * 
 */

import java.util.*;
import java.util.stream.*;

public class Test {

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        int range = Integer.parseInt(scanner.nextLine());

        Set<Integer> result = new HashSet<>();
        StringBuilder answers = new StringBuilder();
        String input = scanner.nextLine();
        while (!input.equals("HELP")) {
            Set<Integer> question = Arrays.stream(input.split(" "))
                    .map(Integer::parseInt)
                    .collect(Collectors.toCollection(HashSet::new));
            if (result.isEmpty()) {
                if (question.size() <= range / 2) {
                    answers.append("NO\n");
                    result = IntStream.rangeClosed(1, range).boxed()
                            .filter(num -> !question.contains(num))
                            .collect(Collectors.toCollection(HashSet::new));
                } else {
                    answers.append("YES\n");
                    result.addAll(question);
                }
            } else {
                question.retainAll(result);
                if (question.size() <= result.size() / 2) {
                    answers.append("NO\n");
                    result.removeAll(question);
                } else {
                    answers.append("YES\n");
                    result.retainAll(question);
                }
            }
            input = scanner.nextLine();
        }
        System.out.print(answers);
        System.out.println(result.stream().map(Object::toString).collect(Collectors.joining(" ")));
    }
}