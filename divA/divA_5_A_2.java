/*
 * A. Стильная одежда 2
 * 
 * // Условие
 * Ограничение времени 	2 секунды
 * Ограничение памяти 	256Mb
 * Ввод 	стандартный ввод или input.txt
 * Вывод 	стандартный вывод или output.txt
 * 
 * Глеб обожает шоппинг. Как-то раз он загорелся идеей подобрать себе кепку, майку, штаны 
 * и ботинки так, чтобы выглядеть в них максимально стильно. В понимании Глеба стильность 
 * одежды тем больше, чем меньше разница в цвете элементов его одежды.
 * 
 * В наличии имеется N1 кепок, N2 маек, N3 штанов и N4 пар ботинок (1 ≤ Ni ≤ 100000). Про 
 * каждый элемент одежды известен его цвет (целое число от 1 до 100000). Комплект одежды — это
 * одна кепка, майка, штаны и одна пара ботинок. Каждый комплект характеризуется максимальной
 * разницей между любыми двумя его элементами. Помогите Глебу выбрать максимально стильный
 * комплект, то есть комплект с минимальной разницей цветов.
 * 
 * // Формат ввода
 * Для каждого типа одежды i (i=1,2,3,4) сначала вводится количество Ni элементов одежды 
 * этого типа, далее в следующей строке — последовательность из Ni целых чисел, описывающих
 * цвета элементов. Все четыре типа подаются на вход последовательно, начиная с кепок и 
 * заканчивая ботинками. Все вводимые числа целые, положительные и не превосходят 100000.
 * 
 * // Формат вывода
 * Выведите четыре целых числа — цвета соответственно для кепки, майки, штанов и ботинок, 
 * которые должен выбрать Глеб из имеющихся для того, чтобы выглядеть наиболее стильно.
 * Если ответов несколько, выведите любой. 
 * 
 * // Примеры
 * 3
 * 1 2 3
 * 2
 * 1 3
 * 2
 * 3 4
 * 2
 * 2 3
 * 
 * 3 3 3 3 
 * 
 * 1
 * 5
 * 4
 * 3 6 7 10
 * 4
 * 18 3 9 11
 * 1
 * 20
 * 
 * 5 6 9 20 
 * 
 * // Решение
 * Решения два, одно хитромудрое, второе попроще. Как водится, хитромудрое работает медленнее.
 * 
 * Первое решение:
 * 1) Для каждого цвета в наборе первого типа одежды произведем следующие операции. 
 *    Во всех последующих наборах бинарным поиском найдём ближайший левый цвет и ближайший 
 *    правый. И того, и другого может не оказаться, есть следующие случаи:
 * а) В наборе есть точно такой же цвет, т.е. нет необходимости искать ближайшие.
 * б) Значения цвета в наборе строго меньше выбранного цвета, соответственно из ближайщих 
 *    есть только левый.
 * в) Значения цвета в наборе строго больше выбранного цвета, аналогично, но ближайший 
 *    цвет правый.
 * г) Есть оба ближайших цвета.
 * Задача в том, чтобы найти общие границы цветов в других наборах одежды для заданного цвета
 * из первого набора. 
 * Первый случай отбрасываем, поскольку совпадающий цвет в любом случае попадёт в границы.
 * Второй и третий случаи позволяют использовать ближайший левый/правый цвет в качестве 
 * соответствующей границы, поскольку для этого набора они являются ближайшими к заданному
 * цвету в принципе. Из всех наборов для общей левой границы выбираем наименьшее значение,
 * для правой - наибольшее.
 * Последний случай неочевиден, поскольку выбор ближайшей границы из двух может не обеспечить
 * минимальную разницу цветов - в том случае, если "дальняя" граница уже внутри общих, 
 * обеспеченных другими наборами, либо её "непокрытая" границами других наборов часть меньше,
 * чем разница между цветом ближней границы и заданным цветом.
 * В худшем случае по условиям задачи можно ожидать 4 набора последнего типа и можно было 
 * бы просто перебрать все комбинации (левая и правая граница для каждого набора - 2^4 = 16
 * комбинаций), но тогда это было бы не хитромудрое решение. Все комбинации, впрочем, 
 * перебирать нет необходимости - если отсортировать все границы, начальной комбинацией
 * принять "у каждого набора выбрана левая граница" и далее поочередно менять левую границу
 * на правую. Поскольку правые границы отсортированы по возрастанию, то каждая новая правая
 * граница "покрывает" предыдущую и исключает возможность предыдущего набора одежды влиять
 * на общую границу. Вместо 2^n таким образом получаем 2*n комбинаций - потребуется всего 
 * один проход.
 * К сожалению в стандартных библиотеках отсутствует SortedList, а TreeSet применить не 
 * выйдет из-за возможного наличия дубликатов (хотя, можно извернуться и вместо голого 
 * значения границы хранить объект-обертку с указанным номером набора), городить свой 
 * велосипед лень, поэтому в текущей реализации максимальные/минимальные значения границ
 * в массиве после добавления/удаления границы ищутся заново - и в этой части алгоритма 
 * получаем O(n^2) вместо O(n*log(n)).
 * Высчитав общие границы, переберем ещё раз каждый набор и определим, какой цвет будет 
 * в итоговом наборе.
 * Из "итоговых наборов" выберем тот, у которого разница границ меньше. 
 * 
 * Второе решение. Объединить все четыре набора в один отсортированный массив. Двигаясь 
 * слева направо, сохраняем значения цветов из разных наборов в массив "текущей одежды" - 
 * - сначала сдвигаем правую границу, пока в массив не попадут цвета из всех 4 наборов, 
 * потом сдвигаем левую границу, пока в массиве присутствуют цвета из всех 4 наборов, 
 * обеспечивая таким образом минимально возможные интервалы между цветами. Чередуя сдвиг 
 * левой и правой границы перебираем весь объединённый массив.
 * 
 */

import java.util.*;
import java.util.function.Function;
import java.util.stream.*;

public class Test {

    static class AllClothesMap {
        Map<Integer, Set<Integer>> clothesMap = new TreeMap<>();

        void add(int type, int color) {
            if (clothesMap.containsKey(color))
                clothesMap.get(color).add(type);
            else
                clothesMap.put(color, new HashSet<>(Collections.singletonList(type)));
        }

        List<Integer> getColors() {
            return new ArrayList<>(clothesMap.keySet());
        }

        Set<Integer> getTypes(int color) {
            return clothesMap.get(color);
        }
    }

    static class CurrentClothes {
        Map<Integer, Integer> clothesMap = IntStream.rangeClosed(1,4).boxed().collect(Collectors.toMap(Function.identity(), type -> 0));

        void add(Set<Integer> types) {
            types.forEach(type -> clothesMap.compute(type, (t, count) -> count + 1));
        }

        void remove(Set<Integer> types) {
            types.forEach(type -> clothesMap.compute(type, (t, count) -> count - 1));
        }

        boolean areAllTypesPresented() {
            return !clothesMap.containsValue(0);
        }
    }

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        AllClothesMap clothesMap = new AllClothesMap();
        scanner.nextLine();
        Arrays.stream(scanner.nextLine().split(" ")).distinct().map(Integer::parseInt).forEach(color -> clothesMap.add(1, color));
        scanner.nextLine();
        Arrays.stream(scanner.nextLine().split(" ")).distinct().map(Integer::parseInt).forEach(color -> clothesMap.add(2, color));
        scanner.nextLine();
        Arrays.stream(scanner.nextLine().split(" ")).distinct().map(Integer::parseInt).forEach(color -> clothesMap.add(3, color));
        scanner.nextLine();
        Arrays.stream(scanner.nextLine().split(" ")).distinct().map(Integer::parseInt).forEach(color -> clothesMap.add(4, color));

        CurrentClothes currentClothesMap = new CurrentClothes();
        int start = 0, end = 0;
        List<Integer> listOfColors = clothesMap.getColors();
        for (int i = 0; i < listOfColors.size(); i++) {
            currentClothesMap.add(clothesMap.getTypes(listOfColors.get(i)));
            if (currentClothesMap.areAllTypesPresented()) {
                end = i;
                break;
            }
        }

        int minDiff = Integer.MAX_VALUE;
        while (end != listOfColors.size()) {
            while (currentClothesMap.areAllTypesPresented()) {
                currentClothesMap.remove(clothesMap.getTypes(listOfColors.get(start)));
                start++;
            }
            start--;
            currentClothesMap.add(clothesMap.getTypes(listOfColors.get(start)));
            minDiff = Math.min(minDiff, listOfColors.get(end) - listOfColors.get(start));
            end++;
            if (end != listOfColors.size())
                currentClothesMap.add(clothesMap.getTypes(listOfColors.get(end)));
        }
        System.out.println(minDiff);
    }
}